{"version":3,"file":"circlepack.umd.min.js","sources":["../../src/Vector2.js","../../src/CirclePackPoint.js","../../src/CirclePackManager.js","../../src/worker-wrapper.js"],"sourcesContent":["export default class Vector2 {\n  constructor(x, y) {\n    this.x = x || 0;\n    this.y = y || 0;\n  }\n\n  add(vec) {\n    this.x += vec.x;\n    this.y += vec.y;\n\n    return this;\n  }\n\n  copy(vec) {\n    this.x = vec.x;\n    this.y = vec.y;\n\n    return this;\n  }\n\n  distanceTo(vec) {\n    return Math.sqrt(this.distanceToSquared(vec));\n  }\n\n  distanceToSquared(vec) {\n    const dx = this.x - vec.x;\n    const dy = this.y - vec.y;\n\n    return dx * dx + dy * dy;\n  }\n\n  divideScalar(scalar) {\n    this.x /= scalar;\n    this.y /= scalar;\n\n    return this;\n  }\n\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n\n  multiplyScalar(scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n\n    return this;\n  }\n\n  normalize() {\n    return this.divideScalar(this.length() || 1);\n  }\n\n  set(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  sub(vec) {\n    this.x -= vec.x;\n    this.y -= vec.y;\n\n    return this;\n  }\n\n  subVectors(vec, vec2) {\n    this.x = vec.x - vec2.x;\n    this.y = vec.y - vec2.y;\n\n    return this;\n  }\n}\n","import Vector2 from './Vector2';\n\nexport default class Point {\n  constructor(opts = {}) {\n    this.position = new Vector2(opts.x, opts.y);\n    this.velocity = new Vector2();\n    this.radius = opts.radius;\n    this.manager = opts.manager;\n\n    this.index = opts.index * 2;\n    this._tmpVec = new Vector2(); // reused for various calculations\n\n    this.updateBackingArray();\n  }\n\n  update() {\n    // apply gravitational force. this moves points towards the manager's defined center at all times\n    const _dist = this.position.distanceTo(this.manager.center);\n    this._tmpVec.subVectors(this.manager.center, this.position).multiplyScalar(_dist / 100000000); // magic numbery. really not sure\n\n    // multiply the gravitational force if circle is outside of the container area.\n    if (_dist > this.manager.radius * (1 - this.manager.tightness)) {\n      this._tmpVec.multiplyScalar(500);\n    }\n\n    this.velocity.add(this._tmpVec);\n\n    if (this.manager.mouseInteractive) {\n      const dist = this.manager.mouse.distanceTo(this.position);\n\n      if (dist < this.manager.mouseRadius) {\n        this._tmpVec.subVectors(this.position, this.manager.mouse).normalize();\n        this.velocity.add(this._tmpVec);\n      }\n    }\n\n    // apply friction and update position based on new velocity\n    this.velocity.multiplyScalar(0.9);\n    this.position.add(this.velocity);\n\n    // apply position to backing array\n    this.updateBackingArray();\n  }\n\n  updateBackingArray() {\n    this.manager.pointsArray[this.index] = this.position.x;\n    this.manager.pointsArray[this.index + 1] = this.position.y;\n  }\n}\n","import Vector2 from './Vector2';\nimport CirclePackPoint from './CirclePackPoint';\n\nexport default class CirclePackManager {\n  constructor(opts = {}) {\n    this.tightness = 1;\n    this.active = true;\n    this.points = [];\n    this.pointsArray = new Float32Array(opts.size || 100);\n    this.center = opts.center || new Vector2();\n    this.area = 0;\n    this.radius = 0;\n    this.updateCallback = opts.onUpdate || null;\n\n    // for optional interaction. positioned offscreen initially\n    this.mouse = new Vector2(window.innerHeight * 2, window.innerHeight * 2);\n    this.mouseRadius = 100;\n    this.mouseInteractive = true;\n\n    this._tmpVec = new Vector2();\n  }\n\n  calculateArea() {\n    this.area = 0;\n\n    for (let i = 0, total = this.points.length; i < total; i += 1) {\n      this.area += this.points[i].radius * this.points[i].radius * Math.PI;\n    }\n\n    this.radius = Math.sqrt(this.area / Math.PI);\n  }\n\n  reset(size) {\n    this.points = [];\n    this.pointsArray = new Float32Array(size * 2);\n  }\n\n  addPoint(x, y, radius) {\n    this.points.push(new CirclePackPoint({\n      x,\n      y,\n      radius,\n      index: this.points.length,\n      manager: this,\n    }));\n  }\n\n  update() {\n    if (!this.active) { return; }\n\n    // pre-instantiate vars so we aren't doing it on each iteration\n    let dist;\n    let radii;\n    let inverseForce;\n    const pointTotal = this.points.length;\n\n    // check every point against every other point\n    for (let i = 0; i < pointTotal; i += 1) {\n      for (let j = 0; j < pointTotal; j += 1) {\n        if (j !== i) { // don't compare this point to itself\n          dist = this.points[i].position.distanceToSquared(this.points[j].position);\n          radii = (this.points[i].radius + this.points[j].radius);\n\n          if (dist < radii * radii) {\n            // get direction between points\n            this._tmpVec.subVectors(this.points[i].position, this.points[j].position).normalize();\n\n            // applying an inverse force helps points come to rest\n            inverseForce = (radii - Math.sqrt(dist));\n            this._tmpVec.multiplyScalar(inverseForce / 3);\n\n            // adjust velocities based on previously calculated distance and direction\n            this.points[i].velocity.add(this._tmpVec);\n            this.points[j].velocity.sub(this._tmpVec);\n          }\n        }\n      }\n\n      this.points[i].update();\n    }\n\n    if (this.updateCallback) {\n      this.updateCallback.call();\n    }\n  }\n}\n","/* eslint-disable no-restricted-globals */\n/* global self */\n\n/**\n * Wraps circle pack manager in a worker-capable function\n */\nexport default function workerWrapper() {\n  class Vector2 {\n    constructor(x, y) {\n      this.x = x || 0;\n      this.y = y || 0;\n    }\n\n    add(vec) {\n      this.x += vec.x;\n      this.y += vec.y;\n\n      return this;\n    }\n\n    copy(vec) {\n      this.x = vec.x;\n      this.y = vec.y;\n\n      return this;\n    }\n\n    distanceTo(vec) {\n      return Math.sqrt(this.distanceToSquared(vec));\n    }\n\n    distanceToSquared(vec) {\n      const dx = this.x - vec.x;\n      const dy = this.y - vec.y;\n\n      return dx * dx + dy * dy;\n    }\n\n    divideScalar(scalar) {\n      this.x /= scalar;\n      this.y /= scalar;\n\n      return this;\n    }\n\n    length() {\n      return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n\n    multiplyScalar(scalar) {\n      this.x *= scalar;\n      this.y *= scalar;\n\n      return this;\n    }\n\n    normalize() {\n      return this.divideScalar(this.length() || 1);\n    }\n\n    set(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n\n    sub(vec) {\n      this.x -= vec.x;\n      this.y -= vec.y;\n\n      return this;\n    }\n\n    subVectors(vec, vec2) {\n      this.x = vec.x - vec2.x;\n      this.y = vec.y - vec2.y;\n\n      return this;\n    }\n  }\n\n  class CirclePackPoint {\n    constructor(opts = {}) {\n      this.position = new Vector2(opts.x, opts.y);\n      this.velocity = new Vector2();\n      this.radius = opts.radius;\n      this.manager = opts.manager;\n\n      this.index = opts.index * 2;\n      this._tmpVec = new Vector2(); // reused for various calculations\n\n      this.updateBackingArray();\n    }\n\n    update() {\n      // apply gravitational force. this moves points towards the manager's defined center at all times\n      const _dist = this.position.distanceTo(this.manager.center);\n      this._tmpVec.subVectors(this.manager.center, this.position).multiplyScalar(_dist / 100000000); // magic numbery. really not sure\n\n      // multiply the gravitational force if circle is outside of the container area.\n      if (_dist > this.manager.radius * (1 - this.manager.tightness)) {\n        this._tmpVec.multiplyScalar(500);\n      }\n\n      this.velocity.add(this._tmpVec);\n\n      if (this.manager.mouseInteractive) {\n        const dist = this.manager.mouse.distanceTo(this.position);\n\n        if (dist < this.manager.mouseRadius) {\n          this._tmpVec.subVectors(this.position, this.manager.mouse).normalize();\n          this.velocity.add(this._tmpVec);\n        }\n      }\n\n      // apply friction and update position based on new velocity\n      this.velocity.multiplyScalar(0.9);\n      this.position.add(this.velocity);\n\n      // apply position to backing array\n      this.updateBackingArray();\n    }\n\n    updateBackingArray() {\n      this.manager.pointsArray[this.index] = this.position.x;\n      this.manager.pointsArray[this.index + 1] = this.position.y;\n    }\n  }\n\n  class CirclePackManager {\n    constructor(opts = {}) {\n      this.tightness = 1;\n      this.active = true;\n      this.points = [];\n      this.pointsArray = new Float32Array(opts.size || 100);\n      this.center = opts.center || new Vector2();\n      this.area = 0;\n      this.radius = 0;\n      this.updateCallback = opts.onUpdate || null;\n\n      // for optional interaction. positioned offscreen initially\n      this.mouse = new Vector2(-200, -200);\n      this.mouseRadius = 200;\n      this.mouseInteractive = true;\n\n      this._tmpVec = new Vector2();\n    }\n\n    calculateArea() {\n      this.area = 0;\n\n      for (let i = 0, total = this.points.length; i < total; i += 1) {\n        this.area += this.points[i].radius * this.points[i].radius * Math.PI;\n      }\n\n      this.radius = Math.sqrt(this.area / Math.PI);\n    }\n\n    reset(size) {\n      this.points = [];\n      this.pointsArray = new Float32Array(size * 2);\n    }\n\n    addPoint(x, y, radius) {\n      this.points.push(new CirclePackPoint({\n        x,\n        y,\n        radius,\n        index: this.points.length,\n        manager: this,\n      }));\n    }\n\n    update() {\n      if (!this.active) { return; }\n\n      // pre-instantiate vars so we aren't doing it on each iteration\n      let dist;\n      let radii;\n      let inverseForce;\n      const pointTotal = this.points.length;\n\n      // check every point against every other point\n      for (let i = 0; i < pointTotal; i += 1) {\n        for (let j = 0; j < pointTotal; j += 1) {\n          if (j !== i) { // don't compare this point to itself\n            dist = this.points[i].position.distanceToSquared(this.points[j].position);\n            radii = (this.points[i].radius + this.points[j].radius);\n\n            if (dist < radii * radii) {\n              // get direction between points\n              this._tmpVec.subVectors(this.points[i].position, this.points[j].position).normalize();\n\n              // applying an inverse force helps points come to rest\n              inverseForce = (radii - Math.sqrt(dist));\n              this._tmpVec.multiplyScalar(inverseForce / 3);\n\n              // adjust velocities based on previously calculated distance and direction\n              this.points[i].velocity.add(this._tmpVec);\n              this.points[j].velocity.sub(this._tmpVec);\n            }\n          }\n        }\n\n        this.points[i].update();\n      }\n\n      if (this.updateCallback) {\n        this.updateCallback.call();\n      }\n    }\n  }\n\n  const circlePackManager = new CirclePackManager();\n\n  self.onmessage = (event) => {\n    if (event.data.action === 'setup') {\n      circlePackManager.reset(event.data.pointCount);\n    } else if (event.data.action === 'update') {\n      circlePackManager.update();\n\n      const points = new Float32Array(circlePackManager.pointsArray);\n\n      postMessage({\n        points: points.buffer,\n      }, [ points.buffer ]);\n    } else if (event.data.action === 'add') {\n      const { point } = event.data;\n\n      circlePackManager.addPoint(point.x, point.y, point.radius);\n    } else if (event.data.action === 'calculateArea') {\n      circlePackManager.calculateArea();\n    } else if (event.data.action === 'updateMouse') {\n      circlePackManager.mouse.x = event.data.x;\n      circlePackManager.mouse.y = event.data.y;\n    } else if (event.data.action === 'updateValue') {\n      circlePackManager[event.data.key] = event.data.value;\n    }\n  };\n}\n"],"names":["Vector2","x","y","add","vec","this","copy","distanceTo","Math","sqrt","distanceToSquared","dx","dy","divideScalar","scalar","length","multiplyScalar","normalize","set","sub","subVectors","vec2","Point","opts","position","velocity","radius","manager","index","_tmpVec","updateBackingArray","update","_dist","center","tightness","mouseInteractive","mouse","mouseRadius","pointsArray","CirclePackManager","active","points","Float32Array","size","area","updateCallback","onUpdate","window","innerHeight","calculateArea","i","total","PI","reset","addPoint","push","CirclePackPoint","dist","radii","inverseForce","pointTotal","j","call","circlePackManager","self","onmessage","event","data","action","pointCount","postMessage","buffer","point","key","value"],"mappings":"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"}